---
// Astro component with client-side script
---

<div id="three-background" class="fixed inset-0 z-10 pointer-events-auto"></div>

<script>
  import * as THREE from "three";
  import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
  import { oklchToRGB, getThemeColors } from "../../lib/colors.js";

  // Initialize Three.js scene
  function initThreeBackground() {
    const container = document.getElementById("three-background");
    if (!container) return;

    // Scene setup
    const scene = new THREE.Scene();

    // Create some 3D geometry for better interaction
    // const geometry = new THREE.BoxGeometry(2, 2, 2);
    const geometry = new THREE.TorusKnotGeometry(1, 0.3, 64, 8);

    // Create material with solid color
    const colors = getThemeColors();
    const backgroundColor = oklchToRGB(colors.background);
    console.log("Background color:", colors.background, "â†’", backgroundColor);

    const colorLinear = new THREE.Color("red");
    // .setRGB(backgroundColor.r, backgroundColor.g, backgroundColor.b)
    // .convertSRGBToLinear();

    const material = new THREE.MeshBasicMaterial({
      color: colorLinear,
      side: THREE.DoubleSide,
      wireframe: true, // Make it wireframe for a subtle effect
    });

    // Create mesh
    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    // Add a few more meshes for variety
    for (let i = 0; i < 5; i++) {
      const clone = mesh.clone();
      clone.position.set(
        (Math.random() - 0.5) * 4,
        (Math.random() - 0.5) * 4,
        (Math.random() - 0.5) * 4
      );
      clone.rotation.set(
        Math.random() * Math.PI,
        Math.random() * Math.PI,
        Math.random() * Math.PI
      );
      scene.add(clone);
    }

    // Setup renderer
    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true,
    });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);

    // Add to DOM
    container.appendChild(renderer.domElement);

    // Setup camera (changed to PerspectiveCamera for better 3D navigation)
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(3, 3, 3);

    // Setup OrbitControls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; // Add smooth damping
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance = 1;
    controls.maxDistance = 10;
    controls.maxPolarAngle = Math.PI;

    // Make controls more subtle for background
    controls.enableZoom = false; // Disable zoom to keep it subtle
    controls.autoRotate = true; // Auto-rotate for ambient movement
    controls.autoRotateSpeed = 30; // Slow rotation

    scene.position.set(0, 1, 0);

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update(); // Update controls in animation loop
      renderer.render(scene, camera);
    }
    animate();

    // Handle resize
    function handleResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener("resize", handleResize);

    function handleThemeChange() {
      return;
      const colors = getThemeColors();
      const backgroundColor = oklchToRGB(colors.background);
      const colorLinear = new THREE.Color()
        .setRGB(backgroundColor.r, backgroundColor.g, backgroundColor.b)
        .convertSRGBToLinear();

      // Update all meshes in the scene
      scene.traverse((child) => {
        if (child instanceof THREE.Mesh && child.material) {
          child.material.color.copy(colorLinear);
        }
      });
    }

    // Listen for theme changes
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.attributeName === "class") {
          handleThemeChange();
        }
      });
    });

    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["class"],
    });

    // Initial theme check
    handleThemeChange();

    // Return cleanup function
    return () => {
      window.removeEventListener("resize", handleResize);
      observer.disconnect();
      controls.dispose();
      if (container && renderer.domElement) {
        container.removeChild(renderer.domElement);
      }
      renderer.dispose();
      geometry.dispose();
      material.dispose();
    };
  }

  // Initialize when DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initThreeBackground);
  } else {
    initThreeBackground();
  }
</script>
